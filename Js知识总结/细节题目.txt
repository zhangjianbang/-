-----有关parseInt（） 和array.map()用法

+ parseInt（String, radix）;//并按照radix数字基数解析字符串，并返回第一个数字。
	+ radix省略或者为0时解析为十进制，参数小于2大于36返回NaN

+ array.map(funtion(value, index, array){});//回调函数可以接受三个参数。但通常回调只会接受一个值
+array.map(callback,...);
-----------------------------------------
！！！------输出什么？ ["1","2","3"].map(parseInt);  ===>1,NaN,NaN;

因为map的回调函数接受了value，index，array。而parseInt只能接受value，index
因而parseInt接受的参数为： (1, 0), (2, 1), (3, 2); 
而根据parseInt规则来说，（1,0）按照十进制解析，输出1；（2, 1）由于radix不能小于2大于36，返回NaN，（3,2）按照二进制解析，二进制没有数字3返回NaN。

------------------------------事件模型---------------------------
原始事件模型，捕获事件模型，冒泡事件模型

1.原始事件模型：ele.onclick = function(){};
2.捕获事件模型：从document向下传递，直到事件对象（目标元素）
3.冒泡事件模型，从事件对象（目标元素）到document
	+ IE只支持冒泡，火狐支持冒泡和捕获。

监听器：addEventListener("load",init,false);
阻止事件冒泡：eve.stopPropagation();

---------------------------- 内存回收/内存泄漏---------------------
内存泄漏：对象引用数不为零，垃圾回收机制无法释放这块内存，造成内存泄漏
内存回收：对象引用书为零，或者给对象null，会使引用数变为0,然后被垃圾回收机制回收。
ES6中规定了两种数据结构：WeakSet 和WeakMap处理内存泄漏。
浏览器的垃圾回收机制：
	+ 全局变量在网页刷新或者关闭时会被回收。
	+ 局部变量在函数被执行完毕后被回收。
	+ 闭包内的局部变量不会被回收。
1.标记清除：当被引用或者正在使用时，标记为“进入环境”，使用完毕则被标记为“离开环境”
2.引用计数：使用一次计数加1，如果计数为0，则被回收。
垃圾回收会有一定周期(自己规定)，并不是立刻回收!

---------------------------跨域-------------------------------------------
同源策略：同源是协议，IP，端口号都相同，不同源的客户端脚本在没有授权的前提下，不能访问对方的数据。

jsonp（script标签的跨域能力），CORS（跨域资源共享），websocket（html5新特征，一种新协议），iframe跨域，设置代理服务器（由服务器代理我们向不同源的服务器请求数据）

----------------------------Ajax---------------------------
异步传输+js+XML
当用户向服务器发送请求时，我们不必等待结果，而是可以同时做其他事情，等服务器响应回来结果时，再显示给用户。
优点：不整体刷新界面，提高了用户体验。
创建Ajax：
	1.创建XMLHttpRequests对象，创建一个异步传输对象
	2.创建一个新的HTTP请求，并指定该HTTP请求的方式（POST，GET），URL和验证信息
	3.设置相应HTTP请求状态变化的函数
	4.发送HTTP请求
	5.获取异步调用的返回的数据
	6.将数据局部刷新到页面上

---------------------------异步和同步----------------------
同步是指下一个程序的执行必须等待上一个程序执行完，也就是出结果后才能执行下一个程序。
异步就是当上一个程序执行时，下一个程序不用等待上一个程序执行完即可执行，等上一个程序执行完调用回调函数再处理。

---------------------------事件委托------------------------
事件委托是利用冒泡事件，只指定一个事件处理程序，用来管理这一类型的所有事件。
（一般给父元素添加事件，管理下面的后代元素事件）
利用event.target来确定后代元素。target指定某个元素。

优点 ：1.减少DOM所添加的事件处理程序，可以优化网页运行的性能。 
          2.减少处理函数的个数，从而减轻内存的占用率。

------------------link 和@import引入CSS的区别---------------------
1.link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务。@import属于CSS范畴，只能加载CSS
2.link引用CSS时，在页面加载时同时载入CSS，而@import只能在页面加载完毕后再加载CSS
3.link是XHTML标签，无兼容问题。@import是CSS2.1提出的，会存在低版本兼容问题。
4.link支持js控制DOM修改CSS样式，@import不支持。

